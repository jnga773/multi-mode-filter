# -*- coding: utf-8 -*-
"""
Created on Thu Apr 16 15:02:49 2020

@author: Jacob
"""

#==============================================================================#
#                              GENERAL FUNCTIONS                               #
#==============================================================================#

def filename(filename_in, parent_in="./data_files/", ext_in="txt"):
    """
    Creates a string for the full filename.

    Input
    ----------
    parent_in : str
        Parent directory where file is.
    file_in : str
        name of file (eg. "parameters", "states")
    ext_in : str
        Extension of file (Default .txt)

    Output
    ----------
    filename_out : str
        Full filename with location ("parent_in/filename_in.ext_in")
    """
    filename_out = parent_in + filename_in + "." + ext_in
    return filename_out

def pi_int(number_in):
    """
    Checks if the number is an integer multiple of pi and, if so, returns a
    string r'{} \pi'.

    Input
    ----------
    number_in : float
        Just a number, ay

    Output
    ----------
    str_out : str
        String label for number in LaTeX r'{} \pi' or r"\frac{\pi}{{}}"
    """
    from numpy import pi, abs
    # If number_in is pretty much pi, set string to r'\pi'
    if round(number_in, 5) == round(pi, 5):
        str_out = r'\pi'
    elif round(number_in, 5) == 0.0:
        str_out = r'0'

    # For larger-than-pi numbers
    if abs(number_in) >= pi and round(number_in, 5) != round(pi, 5):
        if round(abs(number_in) % pi, 5) == 0:
            # Modulus is zero so number_in is an integer of pi
            # Set string
            str_out = r'{} \pi'.format(int(number_in // pi))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{} \pi'.format(round(number_in, 3))

    # For less-than-pi numbers
    elif abs(number_in) < pi and round(number_in, 5) != 0.0:
        if round(pi % number_in, 5) == 0:
            # Modulus is zero so number_in is a rational of pi
            str_out = r'\frac{{\pi}}{{{}}}'.format(int(pi // number_in))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{} \pi'.format(round(number_in, 3))

    # Return string
    return str_out

def spectrum(tau_input, corr_input, pos=None, norm="integral"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Input
    ------------
    tau_input : array_like
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.
        "None" - No normalisation

    Output
    ------------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlise_output : array_like
        List of frequencies
    """
    from numpy.fft import fft, fftshift, fftfreq
    from numpy import where, mean, zeros, pi, array
    from numpy import sum as npsum
    from numpy import max as npmax
    # Shift the arrays so they are arranged from negative to positive freq
    fft = fft(corr_input)#, norm='ortho')
    fft = fftshift(fft)
    freq = fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = where(freq > 0.0)[0]
    elif pos is False:
        indices = where(freq < 0.0)[0]
    elif pos is None:
        indices = where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Take only the real part
    spec_output = spec_output.real
    # take away non zero tails
    spec_output = spec_output - mean(spec_output[0])
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = array(wlist_output) * 2 * pi
    if norm == "integral":
        if npmax(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = npsum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if npmax(spec_output) == 0.0:
            spec_output = zeros(len(wlist_output))
        else:
            spec_output = spec_output / npmax(spec_output)
    elif norm == "none":
        spec_output = spec_output
    return spec_output, wlist_output

def norm_spectra(Omega_in, atom_spec_in, filtered_spec_in, w0_in):
    """
    Depending on where the filter is centred, normalise the filtered spectrum
    to the relevant peak.
    """
    from numpy import array
    # Calculate where the peaks are located in the UNfiltered spectrum
    from scipy.signal import find_peaks
    peaks = find_peaks(atom_spec_in, height=0.1)[1]["peak_heights"]

    # Calculate where the peaks should fall from eigenvalues
    peaks_calculated = array([-Omega_in, 0.0, Omega_in])
    # print(peaks_calculated)

    # Cycle through peaks_calculated and compare with w0
    norm_peak_value = 1.0
    for place, item in enumerate(peaks_calculated):
        if round(item, 2) == round(w0_in, 2):
            # save the peak value
            norm_peak_value = peaks[place]
            # Leave loop
            break
    # Renormalise spectra
    spec_out = filtered_spec_in * norm_peak_value
    return spec_out

# -*- coding: utf-8 -*-
"""
Created on Thu Apr 16 15:02:49 2020

@author: Jacob
"""

#==============================================================================#
#                              GENERAL FUNCTIONS                               #
#==============================================================================#

def filename(filename_in, parent_in="./data_files/", ext_in="txt"):
    """
    Creates a string for the full filename.

    Input
    ----------
    parent_in : str
        Parent directory where file is.
    file_in : str
        name of file (eg. "parameters", "states")
    ext_in : str
        Extension of file (Default .txt)

    Output
    ----------
    filename_out : str
        Full filename with location ("parent_in/filename_in.ext_in")
    """
    filename_out = parent_in + filename_in + "." + ext_in
    return filename_out

def pi_int(number_in):
    """
    Checks if the number is an integer multiple of pi and, if so, returns a
    string r'{} \pi'.

    Input
    ----------
    number_in : float
        Just a number, ay

    Output
    ----------
    str_out : str
        String label for number in LaTeX r'{} \pi' or r"\frac{\pi}{{}}"
    """
    from numpy import pi, abs
    # If number_in is pretty much pi, set string to r'\pi'
    if round(number_in, 5) == round(pi, 5):
        str_out = r'\pi'
    elif round(number_in, 5) == 0.0:
        str_out = r'0'

    # For larger-than-pi numbers
    if abs(number_in) >= pi and round(number_in, 5) != round(pi, 5):
        if round(abs(number_in) % pi, 5) == 0:
            # Modulus is zero so number_in is an integer of pi
            # Set string
            str_out = r'{} \pi'.format(int(number_in // pi))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{} \pi'.format(round(number_in, 3))

    # For less-than-pi numbers
    elif abs(number_in) < pi and round(number_in, 5) != 0.0:
        if round(pi % number_in, 5) == 0:
            # Modulus is zero so number_in is a rational of pi
            str_out = r'\frac{{\pi}}{{{}}}'.format(int(pi // number_in))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{} \pi'.format(round(number_in, 3))

    # Return string
    return str_out

def spectrum(tau_input, corr_input, pos=None, norm="integral"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Input
    ------------
    tau_input : array_like
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.
        "None" - No normalisation

    Output
    ------------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlise_output : array_like
        List of frequencies
    """
    from numpy.fft import fft, fftshift, fftfreq
    from numpy import where, mean, zeros, pi, array
    from numpy import sum as npsum
    from numpy import max as npmax
    # Shift the arrays so they are arranged from negative to positive freq
    fft = fft(corr_input)#, norm='ortho')
    fft = fftshift(fft)
    freq = fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = where(freq > 0.0)[0]
    elif pos is False:
        indices = where(freq < 0.0)[0]
    elif pos is None:
        indices = where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Take only the real part
    spec_output = spec_output.real
    # take away non zero tails
    spec_output = spec_output - mean(spec_output[0])
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = array(wlist_output) * 2 * pi
    if norm == "integral":
        if npmax(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = npsum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if npmax(spec_output) == 0.0:
            spec_output = zeros(len(wlist_output))
        else:
            spec_output = spec_output / npmax(spec_output)
    elif norm == "none":
        spec_output = spec_output
    return spec_output, wlist_output


def norm_spectra(atom_spectra_in, filtered_spectra_in, wlist_in,
                 height_in=0.01):
    """
    Normalises the filtered spectrum [filtered_spectra_in] to the relevant
    peak in the atomic spectrum [atom_spectra_in] depending on where
    the max filtered peak is.

    Parameters
    ----------
    atom_spectra_in : float, array
          Unfiltered atomic spectrum.
    filtered_spectra_in : float, array
          Filtered spectrum.
    wlist_in : float, array
          List of frequencies from the FFT process.
    height_in : float
          Minimum height to detect peaks from scipy.signal.find_peaks()

    Returns
    -------
    norm_spec_out : float, array
          Normalised filtered spectrum to the relevant peak in the atomic
          spectrum.
    """
    from numpy import where
    # Calculate where the peaks are located in the UNfiltered spectrum
    from scipy.signal import find_peaks

    # Calculate where the peaks in the atomic spectrum are and their heights
    atom_peak_where, atom_peak_heights = find_peaks(
        atom_spectra_in, height=height_in)
    atom_peak_heights = atom_peak_heights["peak_heights"]

    # Calculate where the maximum peak in the filtered spectrum is
    filtered_peak_where, filtered_peak_heights = find_peaks(
        filtered_spectra_in, height=height_in)
    filtered_peak_heights = filtered_peak_heights["peak_heights"]

    # Grab index for where the max filtered peak is
    where_filtered_max = where(
        filtered_peak_heights == max(filtered_peak_heights))[0][0]
    where_filtered_max = filtered_peak_where[where_filtered_max]

    # Turn indices into frequencies so we can round a little bit, just in case :)
    w_filtered_max = round(wlist_in[where_filtered_max], 3)

    # Cycle through peaks_calculated and compare with w0
    norm_peak_value = 1.0
    for place, item in enumerate(atom_peak_where):
        if round(wlist_in[item], 3) == w_filtered_max:
            # Save the peak_value
            norm_peak_value = atom_peak_heights[place]
            # Leave loop
            break

    # Renormalise spectra
    spec_out = filtered_spectra_in * norm_peak_value
    return spec_out

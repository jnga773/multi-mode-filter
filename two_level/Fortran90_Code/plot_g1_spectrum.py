# -*- coding: utf-8 -*-
"""
Created on Sat Sep 28 10:27:11 2019

@author: Jacob
"""

import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['text.usetex'] = True
plt.rcParams['font.family'] = 'serif'

plt.close('all')

#-----------------------------------------------------------------------------#
#                                  FILENAMES                                  #
#-----------------------------------------------------------------------------#
# Parameters
filename_parameters = "./data_files/g1_parameters.txt"
# Data
filename_data = "./data_files/g1_corr.txt"

#-----------------------------------------------------------------------------#
#                                  FUNCTIONS                                  #
#-----------------------------------------------------------------------------#

def pi_int(number_in):
    """
    Checks if the number is an integer multiple of pi and, if so, returns a
    string r'{} \pi'.

    Parameters
    ----------
    number_in : float
        Just a number, ay

    Returns
    -------
    str_out : str
        String label for number in LaTeX r'{} \pi' or r"\frac{\pi}{{}}"
    """
    from numpy import pi, abs
    # If number_in is pretty much pi, set string to r'\pi'
    if round(number_in, 5) == round(pi, 5):
        str_out = r'\pi'
    elif round(number_in, 5) == 0.0:
        str_out = r'0'

    # For larger-than-pi numbers
    if round(abs(number_in), 5) >= round(pi, 5) and round(number_in, 5) != round(pi, 5):
        if round(abs(number_in) % pi, 5) == 0:
            # Modulus is zero so number_in is an integer of pi
            # Set string
            str_out = r'{} \pi'.format(int(number_in // pi))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{}'.format(round(number_in, 3))

    # For less-than-pi numbers
    elif round(abs(number_in), 5) < round(pi, 5) and round(number_in, 5) != 0.0:
        if round(round(pi, 7) % round(number_in, 7), 5) == 0:
            # Modulus is zero so number_in is a rational of pi
            str_out = r'\frac{{\pi}}{{{}}}'.format(int(round(pi, 7) // round(number_in, 7)))
        else:
            # It's not an integer of pi so round it to 3dp
            str_out = r'{}'.format(round(number_in, 3))

    # Return string
    return str_out

def spectrum(tau_input, corr_input, pos=None, norm="integral"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Parameters
    ------------
    tau_input : array_like
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.
        "None" - No normalisation

    Returns
    -------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlist_output : array_like
        List of frequencies
    """
    from numpy.fft import fft, fftshift, fftfreq
    from numpy import where, mean, zeros, pi, array
    from numpy import sum as npsum
    from numpy import max as npmax
    # Shift the arrays so they are arranged from negative to positive freq
    fft = fft(corr_input)#, norm='ortho')
    fft = fftshift(fft)
    freq = fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = where(freq > 0.0)[0]
    elif pos is False:
        indices = where(freq < 0.0)[0]
    elif pos is None:
        indices = where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Take only the real part
    spec_output = spec_output.real
    # take away non zero tails
    spec_output = spec_output - mean(spec_output[0])
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = array(wlist_output) * 2 * pi
    if norm == "integral":
        if npmax(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = npsum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if npmax(spec_output) == 0.0:
            spec_output = zeros(len(wlist_output))
        else:
            spec_output = spec_output / npmax(spec_output)
    elif norm == "none":
        spec_output = spec_output
    return spec_output, wlist_output

def calc_mollow_triplet(gamma_in, Omega_in, tau_in):
    """
    Calculates the power spectrum (Mollow triplet) for a driven two-level atom.
    """
    from qutip import sigmam, correlation_2op_1t
    from numpy import sqrt
    
    # Operators
    sm = sigmam()
    
    # Hamiltonian
    H = 0.5 * Omega_in * (sm + sm.dag())
    
    # Collapse and evaluation operators
    c_ops = [sqrt(gamma_in) * sm]
    
    #----------------------------------------------------#
    #     Calculate First-Order Correlation Function     #
    #----------------------------------------------------#
    # Calculate the first-order correlation function
    G1_out = correlation_2op_1t(H, None, tau_in, c_ops, a_op=sm.dag(), b_op=sm,
                                reverse=False)
    # Calculate spectrum
    mollow_out, wlist_f = spectrum(tau, G1_out)
    mollow_out = mollow_out.real
    mollow_out *= 1 / max(mollow_out)
    
    return mollow_out

def norm_spectra(atom_spectra_in, filtered_spectra_in, wlist_in, w0_in,
                 height_in=0.01):
    # Calculate where the peaks are located in the UNfiltered spectrum
    from scipy.signal import find_peaks

    # Calculate where the peaks in the atomic spectrum are and their heights
    atom_peak_where, atom_peak_heights = find_peaks(atom_spectra_in, height=height_in)
    atom_peak_heights = atom_peak_heights["peak_heights"]
    
    # Calculate where the maximum peak in the filtered spectrum is
    filtered_peak_where, filtered_peak_heights = find_peaks(filtered_spectra_in, height=height_in)
    filtered_peak_heights = filtered_peak_heights["peak_heights"]
    
    # Set peak_index
    if w0_in > 0:
        peak_index = -1
    elif w0_in < 0:
        peak_index = 1
    
    # Normalise filtered spectrum to peak_index's peak
    # print("Filtered peak height = ", filtered_peak_heights[peak_index])
    spec_out = filtered_spectra_in / filtered_peak_heights[peak_index]
    
    # Normalise filtered spectra to the Mollow triplet height
    spec_out *= atom_peak_heights[peak_index]
    
    return spec_out

#------------------------------------------------------------------------------#
#                                FILENAME THINGS                               #
#------------------------------------------------------------------------------#
# Read parameters
gamma, Omega, N, halfwidth, kappa, dw, w0 = \
    np.genfromtxt(filename_parameters, delimiter="=", usecols=1)
N = int(N)

Omega_str = pi_int(Omega)
w0_str = pi_int(w0)

# Read data from file
tau = np.genfromtxt(filename_data, usecols=0)
g1_filter = np.genfromtxt(filename_data, usecols=1) + 1j * \
            np.genfromtxt(filename_data, usecols=2)

# Calculate Fourier transform
spec_filter, wlist = spectrum(tau, g1_filter, norm='peak')

# Calculate Mollow triplet spectrum
spec_atom = calc_mollow_triplet(gamma, Omega, tau)

# Renormalise filtered spectra
# print(norm_spectra(spec_atom, spec, w0))
spec = norm_spectra(spec_atom, spec_filter, wlist, w0)

#-----------------------------------------------------------------------------#
#                               PLOT G^{(1)}                                  #
#-----------------------------------------------------------------------------#
# fig, ax = plt.subplots(2, 1, sharex=True, figsize=[8, 6])

# # Real part
# ax[0].plot(tau, corr.real, color='C0', ls='solid', lw=2.0, label='Filtered Spectrum')
# ax[0].plot(tau, corr_atom.real, color='C1', ls='dashed', lw=1.0, label='Full Spectrum')
# ax[0].set_ylabel(r'Real Part', fontsize=15)
# ax[0].set_xlim(-0.2, 5.2)
# ax[0].legend(loc='best', fontsize=15)
# ax[0].set_title(r'$G^{{(1)}}(\tau)$ with $\left( \Omega = {} \gamma \right)$'.format(Omega), fontsize=15)

# ax[1].plot(tau, corr.imag, color='C0', ls='solid', lw=2.0)
# ax[1].plot(tau, corr_atom.imag, color='k', ls='dashed', lw=1.0, alpha=0.5)
# ax[1].set_ylabel(r'Imaginary Part', fontsize=15)
# ax[1].set_xlabel(r'$\gamma t$', fontsize=15)
# ax[1].set_title(r'$N = {}, \kappa = {} \gamma, \omega_{{0}} = {} \gamma, \delta\omega = {} \gamma, \epsilon = {}$'.format(N, kappa, w0, dw, epsilon), fontsize=15)


# fig.tight_layout()
# fig.show()

#-----------------------------------------------------------------------------#
#                               PLOT SPECTRUM                                 #
#-----------------------------------------------------------------------------#
fig = plt.figure(num='Filtered Spectrum', figsize=[8, 8])
ax = plt.gca()

#--------------#
#     Plot     #
#--------------#
# Legend
if N == 0:
    leg_label = (r'Single-Mode $\left( N = {}, \kappa / \gamma = {} \right)$'
                 ).format(N, halfwidth)
else:
    leg_label = (r'Multi-Mode $\left(N = {}, N \delta\omega / \gamma = {} \right)$'
                 ).format(N, halfwidth)

# Plot: Mollow triplet
ax.plot(wlist, spec_atom, color='k', alpha=0.5, ls='dotted')

# Plot: Filtered Spectrum
ax.plot(wlist, spec_filter, color='C0', ls='solid', label=leg_label)

ax.legend(loc='upper right', fontsize=8)

#---------------------#
#     Axis Limits     #
#---------------------#
ax.set_xlim(-1.5 * Omega, 1.5 * Omega)
ax.set_ylim(-0.05, 1.05)

#---------------------#
#     Axis Labels     #
#---------------------#
ax.set_xlabel(r'$\left( \omega - \omega_{A} \right) / \gamma$', fontsize=11)
ax.set_ylabel(r'Power Spectrum (a.u.)', fontsize=11)

ax.set_title((r'$\Omega / \gamma = {}$ with $\omega_{{0}} / \gamma = {}$'
              ).format(Omega_str, w0_str), fontsize=11)

#----------------------#
#     Figure Stuff     #
#----------------------#
fig.tight_layout()
fig.show()

#-----------------------------------------------------------------------------#
#                          PLOT G^{(1)} AND SPECTRUM                          #
#-----------------------------------------------------------------------------#
# fig, ax = plt.subplots(nrows=1, ncols=2, figsize=[12, 8])

# # First-order correlation
# ax[0].plot(tau, corr.real, color='C0', ls='solid', lw=2.0,
#            label='Real')
# ax[0].plot(tau, corr.imag, color='C1', ls='dashed', lw=1.0,
#            label='Imaginary')
# ax[0].set_xlim(-0.1, 10.1)

# ax[0].set_xlabel(r'$\gamma \tau$', fontsize=12)
# ax[0].set_ylabel(r'$G^{(1)}(\tau)$', fontsize=12)
# ax[0].set_title(r'$\Omega = {} \gamma$'.format(Omega_str), fontsize=12)
# ax[0].legend(loc='best', fontsize=12)

# # Spectra
# ax[1].plot(wlist, spec, color='C0', ls='solid', lw=2.0,
#            label='Filtered')
# ax[1].plot(wlist, spec_atom, color='k', ls='dashed', lw=1.0, alpha=0.5,
#            label='Unfiltered')

# ax[1].set_xlim(-1.2 * Omega, 1.2 * Omega)
# ax[1].set_xlabel(r'$\left( \omega - \omega_{d} \right) / \gamma$', fontsize=12)
# ax[1].set_ylabel('Power Spectrum (a.u.)', fontsize=12)
# ax[1].set_title((r'$N = {}, \delta\omega = {} \gamma, \kappa = {} \gamma, '
#                  r'\omega_{{0}} = {} \gamma$'
#                  ).format(N, dw, kappa, w0_str), fontsize=12)
# ax[1].legend(loc='best', fontsize=12)

# fig.tight_layout()
# fig.show()
